<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planets</title>
</head>
<style>

    @font-face {
        font-family: 'comp';
        src: url(./font.ttf);
    }

    body {
        margin: 0;
        overflow: hidden;
        padding: 0;
        font-family: 'comp';
        overflow: hidden;
    }

    canvas {
        max-width: 100%;
        max-height: 100%;
        width: 100%;
        height: 100%;
        display: block;
    }

    #tutorial {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 2rem;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 1.5em;
        z-index: 100;
        pointer-events: none;
        user-select: none;
    }

    #hud {
        position: absolute;
        top: 0;
        right: 0;
        padding: 1rem;
        color: white;
        z-index: 100;
        line-height: 1.5;
    }

    #shipMode {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    #shipMode p {
        margin: 0;
    }

    #touchUI {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        width: 80vw;
        margin: 0 auto;
        padding: 1rem;
        justify-content: space-around;
        z-index: 100;
        max-width: 100%;
        display: flex;
        flex-direction: row;
        /* flex-wrap: wrap; */
    }

    #touchTips {
        position: absolute;
        top: 6rem;
        left: 0;
        right: 0;
        width: 80vw;
        margin: 0 auto;
        padding: 0;
        justify-content: space-around;
        z-index: 100;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        font-size: .8em;
        user-select: none;
        border-radius: 1rem;
        line-height: 1.5;
        font-family: 'Arial';
        overflow: hidden;
    }

    #touchTips p {
        margin: 0;
        height: 0;
        line-height: 0;
        color: transparent;
    }

    #touchTips p.currentTip {
        height: auto;
        line-height: 1.5;
        padding: 1rem;
        color: white;
    }

    .touchButton {
        padding: 1rem;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        font-size: 2rem;
    }

    .touchButton:active {
        background-color: rgba(0, 0, 0, 0.8);
    }

    #forward {
        transform: rotate(180deg);
    }

    #left {
        transform: rotate(90deg);
    }

    #right {
        transform: rotate(-90deg);
    }

    #lr {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        width: 150%;
    }

    #dpad {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .active {
        background-color: rgba(0, 119, 255, 0.8);
    }

    #btns {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
    }

    #shipModeTouch {
        transition: opacity 1s;
        pointer-events: none;
    }

    #accelToggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        padding: .5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.5);
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        opacity: 0;
        transition: opacity 1s;
    }
</style>
<body>
    <!-- <div id="tutorial">
        <h1>Controls</h1>
        <p>Click to lock the camera to the player</p>
        <p>WASD to move, Space to fly upwards</p>
        <p>Hold Shift to boost</p>
        <p>Q and E to rotate</p>
        <p>T to toggle spaceship mode. By default, you will be affected by gravity.<br><br> In Intergalactic Mode, you will not be effected by gravity and fly faster</p>
        <p>Press Escape to unlock the mouse and see these instructions again</p>
    </div> -->
    <div id="touchTips">
        <p data-delay="7000" class="currentTip">Welcome! Swipe the screen to look around, and press the arrow buttons to fly your ship</p>
        <p data-delay="5000">When in Landing mode, (like right now) you are affected by planet's gravity</p>
        <p data-takeoff="true">After Takeoff, you can fly faster and are unaffected by gravity</p>
        <p data-delay="7000" data-tilt="true">Swipe to steer your ship while in Takeoff mode. You can also roll your ship by tilting your device. Try steering with one finger while pressing a direction key with another.</p>
        <p data-delay="5000">Gravity fields are represented as spheres around planets</p>
        <p data-delay="7000">Some gravity fields are stronger than others, and will conflict with each other. You may be unable to land if you are too close to multiple planets</p>
        <p data-delay="7000">Your ship will orient itself to the closest planet's gravity field when in Landing mode. You will also match the planet's rotation and move with it</p>
    </div>
    <div id="touchUI" style="display: none;">
        <div id="accelToggle">
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="M496-182 182-496q-23-23-23-54t23-54l174-174q23-23 54-23t54 23l314 314q23 23 23 54t-23 54L604-182q-23 23-54 23t-54-23Zm54-58 170-170-310-310-170 170 310 310ZM480 0q-99 0-186.5-37.5t-153-103Q75-206 37.5-293.5T0-480h80q0 71 24 136t66.5 117Q213-175 272-138.5T401-87L296-192l56-56L588-12q-26 6-53.5 9T480 0Zm400-480q0-71-24-136t-66.5-117Q747-785 688-821.5T559-873l105 105-56 56-236-236q26-6 53.5-9t54.5-3q99 0 186.5 37.5t153 103q65.5 65.5 103 153T960-480h-80Zm-400 0Z"/></svg>
        </div>
        <div id="dpad">
            <div id="forward" class="touchButton">V</div>
            <div id="lr">
                <div id="left" class="touchButton">V</div>
                <div id="right" class="touchButton">V</div>
            </div>
            <div id="back" class="touchButton">V</div>
        </div>
        <div id="btns">
            <div id="boostBtn" class="touchButton">Boost</div>
            <div id="shipModeTouch" class="touchButton" style="opacity: 0;">Takeoff</div>    
        </div>
      
    </div>
    <div id="hud">
        <div id="shipMode">
            <p>Spaceship Mode: <span id="spaceship">Surface Explorer<br>Press T to Takeoff</span></p>
            <!-- <p>Boost: <span id="boost">0</span></p> -->
        </div>
    </div>
</body>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three/build/three.module.js",
            "cannon-es": "https://unpkg.com/cannon-es/dist/cannon-es.js"
        }

    }
</script>
<script type="module">
    import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/OutputPass.js';
    import CannonDebugger from 'https://unpkg.com/cannon-es-debugger/dist/cannon-es-debugger.js'
    import Stats from 'https://unpkg.com/three/examples/jsm/libs/stats.module.js';
    import Planet from './Planet.js';
    import Player from './Player.js';

    let scene, camera, renderer, controls, composer;
    let clock = new THREE.Clock();
    let world, cannonDebugger;

    let stats = new Stats();
    stats.showPanel(0);
    // document.body.appendChild(stats.dom);

    let meshMap = new Map();

    let stars;

    let player, playerBody, playerMesh;

    let sun;
    let spring;
    let line;

    let light;
    let canvas;

    let planets = [];
    const simSpeed = 1;

    const PLAYER_GROUP = 1 << 0;
    const EVERYTHING_ELSE_GROUP = 1 << 1;

    let keys = {}

    // let tut = document.getElementById('tutorial');
    let hud = document.getElementById('hud');
    let spaceship = document.getElementById('spaceship');
    let boost = document.getElementById('boost');
    let touchUI;

    let touchFwd = document.getElementById('forward');
    let touchBack = document.getElementById('back');
    let touchLeft = document.getElementById('left');
    let touchRight = document.getElementById('right');
    let boostToggle = document.getElementById('boostBtn')
    let takeoffToggle = document.getElementById('shipModeTouch');

    let accelToggle = document.getElementById('accelToggle');
    let accel = true;

    init();
    animate();

    document.addEventListener('DOMContentLoaded', () => {
        nextTip(0, 5000);
    });

    function nextTip(idx, delay) {
        let tips = document.getElementById('touchTips').children;
        let currentTip = tips[idx];
        if(currentTip.dataset.takeoff) {
            takeoffToggle.style.opacity = 1;
            takeoffToggle.style.pointerEvents = 'auto';
        }
        if(currentTip.dataset.tilt) {
            accelToggle.style.opacity = 1;
            accelToggle.style.pointerEvents = 'auto';
        }
        let nextTipIdx = tips[idx + 1];
        if(nextTipIdx) {
            setTimeout(() => {
                currentTip.classList.remove('currentTip');
                nextTipIdx.classList.add('currentTip');
                if(nextTipIdx.dataset.delay) {
                    delay = nextTipIdx.dataset.delay;
                }
                nextTip(idx + 1, delay);
            }, delay);
        } else {
            setTimeout(() => {
                currentTip.classList.remove('currentTip');
            }, delay);
        }
    }
    

    function init() {
        
        sceneSetup();
        rendererSetup();
        cameraSetup();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        worldSetup();
        createObjects();
        lightSetup();
        createPlayer();

        

        let keyDownListener = function(event) {
            event.preventDefault();
            // console.log(event.code);
            keys[event.code] = true;
        };

        let keyUpListener = function(event) {
            event.preventDefault();
            // console.log(event.code);
            keys[event.code] = false;
        };

        window.addEventListener('keydown', keyDownListener);
        window.addEventListener('keyup', keyUpListener);

        touchFwd.addEventListener('touchstart', () => {
            keys['KeyW'] = true;
        });
        touchFwd.addEventListener('touchend', () => {
            keys['KeyW'] = false;
        });

        touchBack.addEventListener('touchstart', () => {
            keys['KeyS'] = true;
        });
        touchBack.addEventListener('touchend', () => {
            keys['KeyS'] = false;
        });

        touchLeft.addEventListener('touchstart', () => {
            keys['KeyA'] = true;
        });
        touchLeft.addEventListener('touchend', () => {
            keys['KeyA'] = false;
        });

        touchRight.addEventListener('touchstart', () => {
            keys['KeyD'] = true;
        });
        touchRight.addEventListener('touchend', () => {
            keys['KeyD'] = false;
        });

        boostToggle.addEventListener('touchstart', () => {
            keys['ShiftLeft'] = !keys['ShiftLeft'];
            if(keys['ShiftLeft']) {
                boostToggle.classList.add('active');
            } else {
                boostToggle.classList.remove('active');
            }
        });

        takeoffToggle.addEventListener('touchstart', () => {
            keys['KeyT'] = true;
        });
        takeoffToggle.addEventListener('touchend', () => {
            keys['KeyT'] = false;
            if(!player.isSpaceShip) {
                takeoffToggle.innerHTML = 'Takeoff';
            } else {
                takeoffToggle.innerHTML = 'Land';
            }
        });

        accelToggle.addEventListener('click', () => {
            accel = !accel;
            if(accel) {
                accelToggle.style.opacity = 1;
            } else {
                accelToggle.style.opacity = .5;
            }
        });
            

        function handleOrientation(event) {
            // alert(event.beta);

            const gamma = event.gamma;

            // Update the player's quaternion based on the device orientation
            let yRotationQuaternion = new CANNON.Quaternion();
            yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), -gamma * .0005);
            playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);


        }

        if (window.DeviceOrientationEvent) {
            window.addEventListener(
                "deviceorientation",
                (event) => {
                const rotateDegrees = event.alpha; // alpha: rotation around z-axis
                const leftToRight = event.gamma; // gamma: left to right
                const frontToBack = event.beta; // beta: front back motion

                if(player.isSpaceShip && accel) handleOrientation(event);
                },
                true,
            );
            } else {
            alert("Sorry, your browser doesn't support Device Orientation");
        }

        // window.addEventListener('click', () => {
        //     tut.style.display = 'none';
        // });

        let touchPoints = {};

        canvas.addEventListener('touchstart', function(event) {
            event.preventDefault();
            for (let i = 0; i < event.touches.length; i++) {
                const touch = event.touches[i];
                touchPoints[touch.identifier] = { startX: touch.clientX, startY: touch.clientY, endX: touch.clientX, endY: touch.clientY };
            }
        });

        canvas.addEventListener('touchmove', function(event) {
            event.preventDefault();
            for (let i = 0; i < event.touches.length; i++) {
                const touch = event.touches[i];
                if (touchPoints[touch.identifier]) {
                    touchPoints[touch.identifier].endX = touch.clientX;
                    touchPoints[touch.identifier].endY = touch.clientY;
                }
            }

            let deltaX = 0;
            let deltaY = 0;
            for (let id in touchPoints) {
                const point = touchPoints[id];
                deltaX += point.endX - point.startX;
                deltaY += point.endY - point.startY;
                point.startX = point.endX;
                point.startY = point.endY;
            }

            // Update playerBody.mouseRotX and playerBody.mouseRotY based on swipe distance
            playerBody.mouseRotX = deltaX
            playerBody.mouseRotY = deltaY
        });

        canvas.addEventListener('touchend', function(event) {
            event.preventDefault();
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                delete touchPoints[touch.identifier];
            }
        });

        if(isTouchDevice()) {
            touchUI = document.getElementById('touchUI');
            touchUI.style.display = 'flex';

            hud.style.display = 'none';
        }


    }

    function isTouchDevice() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }
    

    function sceneSetup() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const textureLoader = new THREE.TextureLoader();
        const milkyWayTexture = textureLoader.load('./stars.jpg', function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;

            // Create a sphere geometry for the background
            const geometry = new THREE.SphereGeometry(1000, 60, 40);
            geometry.scale(-1, 1, 1); // Invert the geometry on the x-axis so that all of the faces point inward

            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1 });

            const backgroundMesh = new THREE.Mesh(geometry, material);
            backgroundMesh.renderOrder = -1; // Ensure it is rendered first

            scene.add(backgroundMesh);


            stars = backgroundMesh;
        });
    }

    function rendererSetup() {
        renderer = new THREE.WebGLRenderer();
        renderer.physicallyCorrectLights = true;
        renderer.antialias = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop( animate );
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        canvas = renderer.domElement;


        composer = new EffectComposer(renderer);
        

    }


    function cameraSetup() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 10, 0);
        camera.near = 0.1;
        camera.far = 10000;
        camera.updateProjectionMatrix();


        // controls = new OrbitControls(camera, renderer.domElement);
        // controls.enableDamping = true;
        // controls.dampingFactor = 0.25;
        // controls.enableZoom = true;

    }

    function worldSetup() {
        world = new CANNON.World();
        world.gravity.set(0, 0, 0);
        world.solver.iterations = 10;
        world.allowSleep = false;
        world.simSpeed = simSpeed;


        cannonDebugger = new CannonDebugger(scene, world, {
            onInit(body, mesh) {
                mesh.visible = false;
                document.addEventListener('keydown', (event) => {
                if (event.key === '=') {
                    mesh.visible = !mesh.visible
                }
                })
            },
        });
    }

   
    function createObjects() {

        

        let gM = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true }));
        gM.rotation.x = Math.PI / 2;
        // scene.add(gM);

        sun = new Planet({
            name: 'sun', 
            scene: scene, 
            world: world,
            color: 0xff0000, 
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(0, 0, 0),
            initialVelocity: new CANNON.Vec3(0, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, .01, 0),
            radius: 100, 
            gravityScale: 1,
            gravityRadius: 1000, 
            mass: 1000, 
            fixed: false
        });
        console.log(sun);
        planets.push(sun);

        let planet1 = new Planet({
            name: 'planet1', 
            scene: scene, 
            world: world, 
            color: 0x00ff00,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(0, 50, 200),
            initialVelocity: new CANNON.Vec3(-2, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, .1, 0),
            radius: 10, 
            gravityScale: 3, 
            gravityRadius: 80, 
            mass: 200, 
            maxOrbitDistance: 100,
            fixed: false
        });
        console.log(planet1);
        planets.push(planet1);

        let planet2 = new Planet({
            name: 'planet2', 
            scene: scene, 
            world: world, 
            color: 0x0000ff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(50, -60, -300),
            initialVelocity: new CANNON.Vec3(-6, 0, 1), 
            initialAngularVelocity: new CANNON.Vec3(0, -.3, 0),
            radius: 20, 
            gravityScale: 3, 
            gravityRadius: 50, 
            mass: 300, 
            maxOrbitDistance: 50,
            fixed: false
        });
        console.log(planet2);
        planets.push(planet2);

        let planet3 = new Planet({
            name: 'planet3', 
            scene: scene, 
            world: world, 
            color: 0x00ffff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(50, 20, -400),
            initialVelocity: new CANNON.Vec3(1, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, -.02, 0),
            radius: 40, 
            gravityScale: 1.5, 
            gravityRadius: 170, 
            mass: 500, 
            maxOrbitDistance: 250,
            fixed: false
        });
        console.log(planet3);
        planets.push(planet3);

        let moon1 = new Planet({
            name: 'moon1', 
            scene: scene, 
            world: world, 
            color: 0xffffff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(100, 0, -250),
            initialVelocity: new CANNON.Vec3(0, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, -.6, 0),
            radius: 10, 
            gravityScale: 1, 
            gravityRadius: 5, 
            mass: 50, 
            maxOrbitDistance: 20,
            fixed: false
        });
        console.log(moon1);
        planets.push(moon1);
        
        let moon2 = new Planet({
            name: 'moon2', 
            scene: scene, 
            world: world, 
            color: 0xffffff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(20, 50, 300),
            initialVelocity: new CANNON.Vec3(10, 0, 10), 
            initialAngularVelocity: new CANNON.Vec3(0, -1, 0),
            radius: 6, 
            gravityScale: 1, 
            gravityRadius: 2, 
            mass: 6, 
            maxOrbitDistance: 0,
            fixed: false
        });
        console.log(moon2);
        planets.push(moon2);

        // for(let i = 0; i < 3; i++) {

        //     let randomColor = '0x' + Math.floor(Math.random()*16777215).toString(16);
        //     randomColor = parseInt(randomColor, 16);

        //     let randomRadius = Math.floor(Math.random() * 50) + 1;
        //     let randomMass = Math.floor(Math.random() * 10) + 1;
        //     let randomGravityScale = Math.floor(Math.random() * 5) + 1;
        //     let randomGravityRadius = Math.floor(Math.random() * 100) + randomRadius;
        //     let randomMaxOrbitDistance = Math.floor(Math.random() * 100) + 20;
        //     let randomPosition = new CANNON.Vec3(Math.floor(Math.random() * 1000 -500), Math.floor(Math.random() * 1000 - 500), Math.floor(Math.random() * 100 - 500));
        //     let randomVelocity = new CANNON.Vec3(Math.floor(Math.random() * 10 - 5), Math.floor(Math.random() * 10 - 5), Math.floor(Math.random() * 10 - 5));

        //     let planet = new Planet({
        //         name: 'planet' + i, 
        //         scene: scene, 
        //         world: world, 
        //         color: randomColor,
        //         simSpeed: simSpeed,
        //         meshMap: meshMap,
        //         position: randomPosition,
        //         initialVelocity: randomVelocity,
        //         radius: randomRadius,
        //         gravityScale: randomGravityScale,
        //         gravityRadius: randomGravityRadius,
        //         mass: randomMass,
        //         maxOrbitDistance: randomMaxOrbitDistance,
        //         fixed: false
        //     });
        //     planets.push(planet);
        // }

        // let planet2 = new Planet({
        //     name: 'planet2', 
        //     scene: scene, 
        //     world: world, 
        //     simSpeed: simSpeed, 
        //     meshMap: meshMap,
        //     position: new CANNON.Vec3(0, 0, -10),
        //     initialVelocity: new CANNON.Vec3(-1, 1, 0), 
        //     radius: 2, 
        //     gravityScale: .1, 
        //     gravityRadius: 6, 
        //     mass: 5, 
        //     fixed: false
        // });
        // console.log(planet2);
        // planets.push(planet2);

        let ground = new CANNON.Body({ mass: 0, collisionFilterGroup: EVERYTHING_ELSE_GROUP, collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP });
        let groundShape = new CANNON.Plane();
        ground.addShape(groundShape);
        ground.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        ground.position.set(0, 0, 0);
        // world.addBody(ground);

        let groundGeometry = new THREE.PlaneGeometry(100, 100);
                    
        let groundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        let groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        groundMesh.position.set(0, 0, 0);

        // scene.add(groundMesh);

        //we will add lines to show the global axes
        

    }

    function createPlayer() {
        let lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
        let lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
        line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        player = new Player({
            name: 'player',
            scene: scene,
            world: world,
            position: new CANNON.Vec3(0, 101, 0),
            camera: camera,
            meshMap: meshMap,
        })
        playerBody = player.body;
        // let playerMesh = player.mesh;
        // console.log(player.mesh);

        scene.player = player;

        // bindMeshToBody(playerMesh, playerBody);

        window.addEventListener('click', () => {
            if(!player.isLocked && !isTouchDevice()) {
                player.enabled = true;
                player.lock();
            }
        });
       

        // playerBody = new CANNON.Body({ mass: .1, fixedRotation: true });
        // let playerShape = new CANNON.Box(new CANNON.Vec3(.1, .2, .1));
        // playerBody.addShape(playerShape);
        // playerBody.position.set(0, 5, 0);
        // playerBody.timeScale = 1;
        // world.addBody(playerBody);


        // let playerGeometry = new THREE.SphereGeometry(.1, 32, 32);
        // let playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        // playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        // playerMesh.castShadow = true;

        // let lineXGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]);
        // let lineXMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        // let lineX = new THREE.Line(lineXGeometry, lineXMaterial);
        // playerMesh.add(lineX);

        // let lineYGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]);
        // let lineYMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        // let lineY = new THREE.Line(lineYGeometry, lineYMaterial);
        // playerMesh.add(lineY);

        // let lineZGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]);
        // let lineZMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        // let lineZ = new THREE.Line(lineZGeometry, lineZMaterial);
        // playerMesh.add(lineZ);

        // let forwardLineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
        // let forwardLineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        // let forwardLine = new THREE.Line(forwardLineGeometry, forwardLineMaterial);
        // playerMesh.add(forwardLine);
    }

    function getClosestPlanet(body) {
        let origin = new CANNON.Vec3(0, 0, 0);
        let closestPlanet = origin;
        let closestDistance = body.position.distanceTo(closestPlanet);
        let closestBody = null;
        planets.forEach(planet => {
            let distance = new CANNON.Vec3().copy(planet.body.position).vsub(body.position).length() - planet.radius;
            if (distance < closestDistance && distance < (planet.gravityRadius - planet.radius)) {
                closestDistance = distance;
                closestPlanet = planet.body.position;
                closestBody = planet.body;
            }
        });
        if(closestPlanet === origin) {
            closestPlanet = null;
        }
        // console.log(closestPlanet); 
        return closestBody;
    }

    function bindMeshToBody(mesh, body) {
        meshMap.set(body, mesh);
    }

    function syncMeshes() {
        world.bodies.forEach((body) => {
            body.angularDamping = 0;
            body.linearDamping = 0;
            let mesh = meshMap.get(body);
            if (mesh) {
                mesh.position.copy(body.position);
                mesh.quaternion.copy(body.quaternion);
            }
        });
    }
    // camera.lookAt(0, 0, 0);

    function lightSetup() {
        light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 100, 0);
        light.castShadow = true;
        light.shadow.bias = -0.0001;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;


        scene.add(light);
    }

  
    function animate() {
        let delta = clock.getDelta();

        // console.log(playerBody

        

        if(player) {

            // if(!player.enabled) tut.style.display = 'flex';

            let playerPosition = playerBody.position;


            light.position.set(playerPosition.x, playerPosition.y + 100, playerPosition.z);
            light.target.position.set(playerPosition.x, playerPosition.y, playerPosition.z);
            light.target.updateMatrixWorld();

            light.shadow.camera.position.set(playerPosition.x, playerPosition.y + 100, playerPosition.z);
            light.shadow.camera.updateProjectionMatrix();

            playerBody.velocity.scale(0.9, playerBody.velocity);
            playerBody.angularVelocity.scale(0.9, playerBody.angularVelocity);

            // align player y axis with planet
            let closestPlanet = getClosestPlanet(playerBody);



            if(camera.posDest) {
                let cameraTargetPos = new THREE.Vector3(camera.posDest.x, camera.posDest.y, camera.posDest.z);
                camera.position.lerp(cameraTargetPos, .1);
            }

            camera.rotation.x = camera.rotation.x + (camera.xDest - camera.rotation.x) * .1;

            if(closestPlanet === null || player.isSpaceShip) {
                playerBody.orbitBody = null;                

                if (playerBody.mouseRotX !== undefined) {
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -playerBody.mouseRotX * .005);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);

                    // Reset mouseRotX to avoid continuous rotation
                    playerBody.mouseRotX = 0;
                }
                if(playerBody.mouseRotY !== undefined) {
                    let xRotationQuaternion = new CANNON.Quaternion();
                    xRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -playerBody.mouseRotY * .005);
                    playerBody.quaternion = playerBody.quaternion.mult(xRotationQuaternion);

                    // Reset mouseRotY to avoid continuous rotation
                    playerBody.mouseRotY = 0;
                }

                if(keys['KeyE']) {
                    //rotate player right
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), -0.05);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);
                }
                if(keys['KeyQ']) {
                    //rotate player left
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), 0.05);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);
                }
                
            } else {

                let planetCenter = closestPlanet.position;
                player.body.orbitBody = closestPlanet;
                let planetUpWorld = playerPosition.vsub(planetCenter);

                let planetUpLocal = playerBody.vectorToLocalFrame(planetUpWorld);                
                let playerUpLocal = new CANNON.Vec3(0, 1, 0);

                playerUpLocal.normalize();
                planetUpLocal.normalize();

                let dot = playerUpLocal.dot(planetUpLocal);
                let angle = Math.acos(dot);

                let axis = playerUpLocal.cross(planetUpLocal);
                axis.normalize();

                let q = new CANNON.Quaternion();
                q.setFromAxisAngle(axis, angle);
                let targetQuaternion = playerBody.quaternion.mult(q);

                playerBody.quaternion = playerBody.quaternion.slerp(targetQuaternion, .1);
                
                let quaternion = new CANNON.Quaternion();
                quaternion.setFromEuler(closestPlanet.angularVelocity.x * delta, closestPlanet.angularVelocity.y * delta, closestPlanet.angularVelocity.z * delta, 'XYZ');
                planetUpWorld = quaternion.vmult(planetUpWorld);

                playerBody.position = planetCenter.vadd(planetUpWorld);
                // playerBody.velocity.copy(closestPlanet.velocity);
                // playerBody.angularVelocity.copy(closestPlanet.angularVelocity);
                // console.log(closestPlanet.velocity, closestPlanet.angularVelocity);
                // console.log(playerBody.velocity, playerBody.angularVelocity);

                if (playerBody.mouseRotX !== undefined) {
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -playerBody.mouseRotX * 0.01);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);

                    playerBody.mouseRotX = 0;
                }
                if(playerBody.mouseRotY !== undefined) {
                    camera.rotation.x -= playerBody.mouseRotY * .005;
                    camera.xDest = camera.xDest - playerBody.mouseRotY * .005;
                    playerBody.mouseRotY = 0;
                }

            }

            if(keys['ShiftLeft']) {
                player.boosting = true;
            } else {
                player.boosting = false;
            }

            let moveSpeed = 50;
            moveSpeed = player.boosting ? moveSpeed * 10 : moveSpeed;

            if(keys['KeyW'] || keys['ArrowUp']) {
                
                playerBody.applyLocalForce(new CANNON.Vec3(0, 0, -moveSpeed), new CANNON.Vec3(0, 0, 0));
            }
            if(keys['KeyS'] || keys['ArrowDown']) {
                playerBody.applyLocalForce(new CANNON.Vec3(0, 0, moveSpeed), new CANNON.Vec3(0, 0, 0));
            }
            if(keys['KeyA'] || keys['ArrowLeft']) {
                playerBody.applyLocalForce(new CANNON.Vec3(-moveSpeed, 0, 0), new CANNON.Vec3(0, 0, 0));
            }
            if(keys['KeyD'] || keys['ArrowRight']) {
                playerBody.applyLocalForce(new CANNON.Vec3(moveSpeed, 0, 0), new CANNON.Vec3(0, 0, 0));

            }
            
            if(keys['Space']) {
                player.spaceDown = true;
            } else {
                player.spaceDown = false;
            }

            if(player.spaceDown) {
                playerBody.applyLocalForce(new CANNON.Vec3(0, moveSpeed*2, 0));
                // console.log(player.body.gravityForce.scale(-100).vadd(new CANNON.Vec3(0, moveSpeed*2, 0)));

            } 
            // if(player.boosting) {
            //     player.boostCapacity > 0 ? player.boostCapacity -= 5 : player.boostCapacity = 0;
            // } else {
            //     player.boostCapacity < 1000 ? player.boostCapacity += 2 : player.boostCapacity = 1000;
            // }
            // boost.innerText = player.boostCapacity <= 0 ? 0 : player.boostCapacity;

            if(stars) stars.position.copy(playerBody.position);

            // console.log(keys)

        }

        world.bodies.forEach(body => {
            body.inOrbit = false;
            body.orbitBody = null;
        });

        scene.planets = planets;


        planets.forEach(planet => {
            planet.update(delta);
        });


        world.step(delta);

        if(keys['KeyT']) {
            player.toggleSpaceShip();
            spaceship.innerHTML = player.isSpaceShip ? 'Intergalactic <br> Zero-Gravity, Higher Speed' : 'Surface Explorer <br> Affected by Gravity';
            keys['KeyT'] = false;
        }
        // console.log(playerBody)
        // console.log(sun.body.position);
        cannonDebugger.update();
        syncMeshes();
        // controls.update();
        // stats.update();
        renderer.render(scene, camera);
    }


</script>

</html>