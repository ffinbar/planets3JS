<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Planets</title>
</head>
<style>

    @font-face {
        font-family: 'comp';
        src: url(./font.ttf);
    }

    body {
        margin: 0;
        overflow: hidden;
        padding: 0;
        font-family: 'comp';
        overflow: hidden;
    }

    canvas {
        max-width: 100%;
        max-height: 100%;
        width: 100%;
        height: 100%;
        display: block;
    }

    #tutorial {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        padding: 2rem;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        font-size: 1.5em;
        z-index: 100;
        pointer-events: none;
        user-select: none;
    }

    #hud {
        position: absolute;
        top: 0;
        right: 0;
        color: white;
        z-index: 100;
        line-height: 1.5;
        width: 100vw;
        height: 100svh;
        margin: 0;
    }

    .controlsList {
        background: rgba(0, 0, 0, 0.5);
        position: absolute;
        bottom: 0;
        display: flex;
        gap: 2rem;
        margin: 0 auto;
        width: 100%;
        justify-content: center;
    }

    #shipMode {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 1.5em;
        padding-top: 1rem;
    }

    #shipMode p {
        margin: 0;
    }

    #touchUI {
        position: absolute;
        bottom: 0;
        left: 0;
        right: 0;
        width: 80vw;
        margin: 0 auto;
        padding: 1rem;
        justify-content: space-around;
        z-index: 100;
        max-width: 100%;
        display: flex;
        flex-direction: row;
        /* flex-wrap: wrap; */
    }

    .tips {
        position: absolute;
        top: 6rem;
        left: 0;
        right: 0;
        width: 80vw;
        margin: 0 auto;
        padding: 0;
        justify-content: space-around;
        z-index: 100;
        max-width: 100%;
        display: flex;
        flex-direction: column;
        align-items: center;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        font-size: .8em;
        user-select: none;
        border-radius: 1rem;
        line-height: 1.5;
        font-family: 'Arial';
        overflow: hidden;
        pointer-events: auto;
    }

    .tips p {
        margin: 0;
        height: 0;
        line-height: 0;
        color: transparent;
    }

    .tips p.currentTip {
        height: auto;
        font-size: 1.5rem;
        line-height: 1.5;
        padding: 1rem;
        color: white;
    }

    .touchButton {
        padding: 1rem;
        background-color: rgba(0, 0, 0, 0.5);
        color: white;
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        font-size: 2rem;
    }

    .touchButton:active {
        background-color: rgba(0, 0, 0, 0.8);
    }

    #forward {
        transform: rotate(180deg);
    }

    #left {
        transform: rotate(90deg);
    }

    #right {
        transform: rotate(-90deg);
    }

    #lr {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
        width: 150%;
    }

    #dpad {
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .active {
        background-color: rgba(0, 119, 255, 0.8);
    }

    #btns {
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
    }

    #shipModeTouch {
        transition: opacity 1s;
        pointer-events: none;
    }

    #accelToggle {
        position: fixed;
        top: 1rem;
        right: 1rem;
        padding: .5rem;
        display: flex;
        justify-content: center;
        align-items: center;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.5);
        cursor: pointer;
        user-select: none;
        -webkit-user-select: none;
        opacity: 0;
        transition: opacity 1s;
    }

</style>
<body>
    <!-- <div id="tutorial">
        <h1>Controls</h1>
        <p>Click to lock the camera to the player</p>
        <p>WASD to move, Space to fly upwards</p>
        <p>Hold Shift to boost</p>
        <p>Q and E to rotate</p>
        <p>T to toggle spaceship mode. By default, you will be affected by gravity.<br><br> In Intergalactic Mode, you will not be effected by gravity and fly faster</p>
        <p>Press Escape to unlock the mouse and see these instructions again</p>
    </div> -->
    <div id="touchTips" class="tips" style="display: none;">
        <p data-delay="10000" class="currentTip">Welcome! Swipe the screen to look around, and press the forward button to fly your ship</p>
        <p data-delay="5000">When in Landing mode, (like right now) you are affected by planet's gravity</p>
        <p data-takeoff="true">After Takeoff, you can fly faster and are unaffected by gravity</p>
        <p data-delay="7000" data-tilt="true">Swipe to steer your ship while in Takeoff mode. You can also roll your ship by tilting your device. Try steering with one finger while pressing the forward button with another.</p>
        <p data-delay="5000">Gravity fields are represented as spheres around planets</p>
        <p data-delay="7000">Some gravity fields are stronger than others, and will conflict with each other. You may be unable to land if you are too close to multiple planets</p>
        <p data-delay="7000">Your ship will orient itself to the closest planet's gravity field when in Landing mode. You will also match the planet's rotation and move with it</p>
    </div>
    <div id="desktopTips" class="tips">
        <p data-delay="10000" class="currentTip">Welcome! Click anywhere to lock the mouse to the player</p>
        <p data-delay="7000">Use the mouse to look around, and Space to fly your ship forward</p>
        <p data-delay="7000">Hold Shift to boost your thrusters</p>
        <p data-delay="15000">Your ship has two modes. In Surface Explorer mode you will be affected by gravity (like right now)</p>
        <p data-delay="5000" data-takeoff="true">Press T to takeoff and enter Intergalactic Mode</p>
        <p data-delay="10000">In Intergalactic Mode, you will not be affected by gravity and can fly faster</p>
        <p data-delay="5000">Your spaceship mode is displayed in the top-left corner</p>
        <p data-delay="5000">Use Q and E to roll your ship</p>
        <p data-delay="5000">Press Escape to unlock the mouse</p>
        <p data-delay="10000">Would you like to see these instructions again? Click <button id="showInstructions">here</button></p>
    </div>
    <div id="touchUI" style="display: none;">
        <div id="accelToggle">
            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 -960 960 960" width="24px" fill="#e8eaed"><path d="M496-182 182-496q-23-23-23-54t23-54l174-174q23-23 54-23t54 23l314 314q23 23 23 54t-23 54L604-182q-23 23-54 23t-54-23Zm54-58 170-170-310-310-170 170 310 310ZM480 0q-99 0-186.5-37.5t-153-103Q75-206 37.5-293.5T0-480h80q0 71 24 136t66.5 117Q213-175 272-138.5T401-87L296-192l56-56L588-12q-26 6-53.5 9T480 0Zm400-480q0-71-24-136t-66.5-117Q747-785 688-821.5T559-873l105 105-56 56-236-236q26-6 53.5-9t54.5-3q99 0 186.5 37.5t153 103q65.5 65.5 103 153T960-480h-80Zm-400 0Z"/></svg>
        </div>
        <div id="dpad">
            <div id="forward" class="touchButton">V</div>
        </div>
        <div id="btns">
            <div id="boostBtn" class="touchButton">Boost</div>
            <div id="shipModeTouch" class="touchButton" style="opacity: 0;">Takeoff</div>    
        </div>
      
    </div>
    <div id="hud">
        <div id="shipMode">
            <p>Spaceship Mode: <span id="spaceship">Surface Explorer</span></p>
            <p id="modeSub"></p>
            <!-- <p>Boost: <span id="boost">0</span></p> -->
        </div>

        <div class="controlsList">
            <p>Space - Thrust Forward</p>
            <p>Shift - Boost</p>
            <p>Q/E - Roll</p>
            <p>T - Toggle Spaceship Mode</p>
            <p>Escape - Unlock Mouse</p>
        </div>

    </div>
</body>
<script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three/build/three.module.js",
            "cannon-es": "https://unpkg.com/cannon-es/dist/cannon-es.js"
        }

    }
</script>
<script type="module">
    import * as THREE from 'three';
    import * as CANNON from 'cannon-es';
    import { OrbitControls } from 'https://unpkg.com/three/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { OutputPass } from 'https://unpkg.com/three/examples/jsm/postprocessing/OutputPass.js';
    import CannonDebugger from 'https://unpkg.com/cannon-es-debugger/dist/cannon-es-debugger.js'
    import Stats from 'https://unpkg.com/three/examples/jsm/libs/stats.module.js';
    import Planet from './Planet.js';
    import Player from './Player.js';

    let scene, camera, renderer, controls, composer;
    let clock = new THREE.Clock();
    let world, cannonDebugger;

    let stats = new Stats();
    stats.showPanel(0);
    // document.body.appendChild(stats.dom);

    let meshMap = new Map();

    let stars;

    let player, playerBody, playerMesh;

    let sun;
    let spring;
    let line;

    let light;
    let canvas;

    let planets = [];
    const simSpeed = 1;

    const PLAYER_GROUP = 1 << 0;
    const EVERYTHING_ELSE_GROUP = 1 << 1;

    let keys = {}

    // let tut = document.getElementById('tutorial');
    let hud = document.getElementById('hud');
    let spaceship = document.getElementById('spaceship');
    let boost = document.getElementById('boost');
    let touchUI, touchTips, desktopTips;

    let touchFwd = document.getElementById('forward');
    let boostToggle = document.getElementById('boostBtn')
    let takeoffToggle = document.getElementById('shipModeTouch');
    let modeSub = document.getElementById('modeSub');

    let showInstructions = document.getElementById('showInstructions');

    let accelToggle = document.getElementById('accelToggle');
    let accel = true;

    init();
    animate();

    document.addEventListener('DOMContentLoaded', () => {
        document.addEventListener('click', () => {
            nextTip(0, 5000);
        }, { once: true });
    });

    showInstructions.addEventListener('click', () => {
        let instructionsParent = showInstructions.parentElement;
        instructionsParent.classList.remove('currentTip');
        desktopTips.style.display = 'flex';
        touchTips.style.display = 'none';
        nextTip(0, 5000);
    });

    function nextTip(idx, delay) {
        let tips = isTouchDevice() ? touchTips.children : desktopTips.children;
        let currentTip = tips[idx];
        if(currentTip.dataset.takeoff) {
            if(isTouchDevice()) {
                takeoffToggle.style.opacity = 1;
                takeoffToggle.style.pointerEvents = 'auto';
            } else {
                modeSub.innerHTML = 'Press T to Takeoff';
            }
        }
        if(currentTip.dataset.tilt) {
            accelToggle.style.opacity = 1;
            accelToggle.style.pointerEvents = 'auto';
        }
        let nextTipIdx = tips[idx + 1];
        if(nextTipIdx) {
            setTimeout(() => {
                currentTip.classList.remove('currentTip');
                nextTipIdx.classList.add('currentTip');
                if(nextTipIdx.dataset.delay) {
                    delay = nextTipIdx.dataset.delay;
                }
                nextTip(idx + 1, delay);
            }, delay);
        } else {
            setTimeout(() => {
                currentTip.classList.remove('currentTip');
            }, delay);
        }
    }
    

    function init() {
        
        sceneSetup();
        rendererSetup();
        cameraSetup();

        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        worldSetup();
        createObjects();
        lightSetup();
        createPlayer();

        

        let keyDownListener = function(event) {
            event.preventDefault();
            // console.log(event.code);
            keys[event.code] = true;
        };

        let keyUpListener = function(event) {
            event.preventDefault();
            // console.log(event.code);
            keys[event.code] = false;
        };

        window.addEventListener('keydown', keyDownListener);
        window.addEventListener('keyup', keyUpListener);

        touchFwd.addEventListener('touchstart', () => {
            keys['Space'] = true;
        });
        touchFwd.addEventListener('touchend', () => {
            keys['Space'] = false;
        });

        boostToggle.addEventListener('touchstart', () => {
            keys['ShiftLeft'] = !keys['ShiftLeft'];
            if(keys['ShiftLeft']) {
                boostToggle.classList.add('active');
            } else {
                boostToggle.classList.remove('active');
            }
        });

        takeoffToggle.addEventListener('touchstart', () => {
            keys['KeyT'] = true;
        });
        takeoffToggle.addEventListener('touchend', () => {
            keys['KeyT'] = false;
            if(!player.isSpaceShip) {
                takeoffToggle.innerHTML = 'Takeoff';
            } else {
                takeoffToggle.innerHTML = 'Land';
            }
        });

        accelToggle.addEventListener('click', () => {
            accel = !accel;
            if(accel) {
                accelToggle.style.opacity = 1;
            } else {
                accelToggle.style.opacity = .5;
            }
        });
            

        function handleOrientation(event) {
            // alert(event.beta);

            const gamma = event.gamma;

            // Update the player's quaternion based on the device orientation
            let yRotationQuaternion = new CANNON.Quaternion();
            yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), -gamma * .0005);
            playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);


        }

        if (window.DeviceOrientationEvent) {
            window.addEventListener(
                "deviceorientation",
                (event) => {
                const rotateDegrees = event.alpha; // alpha: rotation around z-axis
                const leftToRight = event.gamma; // gamma: left to right
                const frontToBack = event.beta; // beta: front back motion

                if(player.isSpaceShip && accel) handleOrientation(event);
                },
                true,
            );
            } else {
            alert("Sorry, your browser doesn't support Device Orientation");
        }

        // window.addEventListener('click', () => {
        //     tut.style.display = 'none';
        // });

        let touchPoints = {};

        canvas.addEventListener('touchstart', function(event) {
            event.preventDefault();
            for (let i = 0; i < event.touches.length; i++) {
                const touch = event.touches[i];
                touchPoints[touch.identifier] = { startX: touch.clientX, startY: touch.clientY, endX: touch.clientX, endY: touch.clientY };
            }
        });

        canvas.addEventListener('touchmove', function(event) {
            event.preventDefault();
            for (let i = 0; i < event.touches.length; i++) {
                const touch = event.touches[i];
                if (touchPoints[touch.identifier]) {
                    touchPoints[touch.identifier].endX = touch.clientX;
                    touchPoints[touch.identifier].endY = touch.clientY;
                }
            }

            let deltaX = 0;
            let deltaY = 0;
            for (let id in touchPoints) {
                const point = touchPoints[id];
                deltaX += point.endX - point.startX;
                deltaY += point.endY - point.startY;
                point.startX = point.endX;
                point.startY = point.endY;
            }

            // Update playerBody.mouseRotX and playerBody.mouseRotY based on swipe distance
            playerBody.mouseRotX = deltaX
            playerBody.mouseRotY = deltaY
        });

        canvas.addEventListener('touchend', function(event) {
            event.preventDefault();
            for (let i = 0; i < event.changedTouches.length; i++) {
                const touch = event.changedTouches[i];
                delete touchPoints[touch.identifier];
            }
        });

        touchUI = document.getElementById('touchUI');
        desktopTips = document.getElementById('desktopTips');
        touchTips = document.getElementById('touchTips');

        if(isTouchDevice()) {
            touchUI.style.display = 'flex';
            desktopTips.style.display = 'none';
            touchTips.style.display = 'flex';

            hud.style.display = 'none';
        } else {
            touchUI.style.display = 'none';
            desktopTips.style.display = 'flex';
            touchTips.style.display = 'none';

            hud.style.display = 'block';
        }


    }

    function isTouchDevice() {
        return 'ontouchstart' in window || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    }
    

    function sceneSetup() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000);

        const textureLoader = new THREE.TextureLoader();
        const milkyWayTexture = textureLoader.load('./stars.jpg', function (texture) {
            texture.mapping = THREE.EquirectangularReflectionMapping;

            // Create a sphere geometry for the background
            const geometry = new THREE.SphereGeometry(1000, 60, 40);
            geometry.scale(-1, 1, 1); // Invert the geometry on the x-axis so that all of the faces point inward

            const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, opacity: 1 });

            const backgroundMesh = new THREE.Mesh(geometry, material);
            backgroundMesh.renderOrder = -1; // Ensure it is rendered first

            scene.add(backgroundMesh);


            stars = backgroundMesh;
        });
    }

    function rendererSetup() {
        renderer = new THREE.WebGLRenderer();
        renderer.physicallyCorrectLights = true;
        renderer.antialias = true;
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop( animate );
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);
        canvas = renderer.domElement;


        composer = new EffectComposer(renderer);
        

    }


    function cameraSetup() {
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
        camera.position.set(0, 10, 0);
        camera.near = 0.1;
        camera.far = 10000;
        camera.updateProjectionMatrix();


        // controls = new OrbitControls(camera, renderer.domElement);
        // controls.enableDamping = true;
        // controls.dampingFactor = 0.25;
        // controls.enableZoom = true;

    }

    function worldSetup() {
        world = new CANNON.World();
        world.gravity.set(0, 0, 0);
        world.solver.iterations = 10;
        world.allowSleep = false;
        world.simSpeed = simSpeed;


        cannonDebugger = new CannonDebugger(scene, world, {
            onInit(body, mesh) {
                mesh.visible = false;
                document.addEventListener('keydown', (event) => {
                if (event.key === '=') {
                    mesh.visible = !mesh.visible
                }
                })
            },
        });
    }

   
    function createObjects() {

        

        let gM = new THREE.Mesh(new THREE.PlaneGeometry(100, 100), new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true }));
        gM.rotation.x = Math.PI / 2;
        // scene.add(gM);

        sun = new Planet({
            name: 'sun', 
            scene: scene, 
            world: world,
            color: 0xff0000, 
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(0, 0, 0),
            initialVelocity: new CANNON.Vec3(0, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, .01, 0),
            radius: 100, 
            gravityScale: 1,
            gravityRadius: 1000, 
            mass: 1000, 
            fixed: false
        });
        console.log(sun);
        planets.push(sun);

        let planet1 = new Planet({
            name: 'planet1', 
            scene: scene, 
            world: world, 
            color: 0x00ff00,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(0, 50, 200),
            initialVelocity: new CANNON.Vec3(-2, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, .1, 0),
            radius: 10, 
            gravityScale: 3, 
            gravityRadius: 80, 
            mass: 200, 
            maxOrbitDistance: 100,
            fixed: false
        });
        console.log(planet1);
        planets.push(planet1);

        let planet2 = new Planet({
            name: 'planet2', 
            scene: scene, 
            world: world, 
            color: 0x0000ff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(50, -60, -300),
            initialVelocity: new CANNON.Vec3(-6, 0, 1), 
            initialAngularVelocity: new CANNON.Vec3(0, -.3, 0),
            radius: 20, 
            gravityScale: 3, 
            gravityRadius: 50, 
            mass: 300, 
            maxOrbitDistance: 50,
            fixed: false
        });
        console.log(planet2);
        planets.push(planet2);

        let planet3 = new Planet({
            name: 'planet3', 
            scene: scene, 
            world: world, 
            color: 0x00ffff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(50, 20, -400),
            initialVelocity: new CANNON.Vec3(1, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, -.02, 0),
            radius: 40, 
            gravityScale: 1.5, 
            gravityRadius: 170, 
            mass: 500, 
            maxOrbitDistance: 250,
            fixed: false
        });
        console.log(planet3);
        planets.push(planet3);

        let moon1 = new Planet({
            name: 'moon1', 
            scene: scene, 
            world: world, 
            color: 0xffffff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(100, 0, -250),
            initialVelocity: new CANNON.Vec3(0, 0, 0), 
            initialAngularVelocity: new CANNON.Vec3(0, -.6, 0),
            radius: 10, 
            gravityScale: 1, 
            gravityRadius: 5, 
            mass: 50, 
            maxOrbitDistance: 20,
            fixed: false
        });
        console.log(moon1);
        planets.push(moon1);
        
        let moon2 = new Planet({
            name: 'moon2', 
            scene: scene, 
            world: world, 
            color: 0xffffff,
            simSpeed: simSpeed, 
            meshMap: meshMap,
            position: new CANNON.Vec3(20, 50, 300),
            initialVelocity: new CANNON.Vec3(10, 0, 10), 
            initialAngularVelocity: new CANNON.Vec3(0, -1, 0),
            radius: 6, 
            gravityScale: 1, 
            gravityRadius: 2, 
            mass: 6, 
            maxOrbitDistance: 0,
            fixed: false
        });
        console.log(moon2);
        planets.push(moon2);

        // for(let i = 0; i < 3; i++) {

        //     let randomColor = '0x' + Math.floor(Math.random()*16777215).toString(16);
        //     randomColor = parseInt(randomColor, 16);

        //     let randomRadius = Math.floor(Math.random() * 50) + 1;
        //     let randomMass = Math.floor(Math.random() * 10) + 1;
        //     let randomGravityScale = Math.floor(Math.random() * 5) + 1;
        //     let randomGravityRadius = Math.floor(Math.random() * 100) + randomRadius;
        //     let randomMaxOrbitDistance = Math.floor(Math.random() * 100) + 20;
        //     let randomPosition = new CANNON.Vec3(Math.floor(Math.random() * 1000 -500), Math.floor(Math.random() * 1000 - 500), Math.floor(Math.random() * 100 - 500));
        //     let randomVelocity = new CANNON.Vec3(Math.floor(Math.random() * 10 - 5), Math.floor(Math.random() * 10 - 5), Math.floor(Math.random() * 10 - 5));

        //     let planet = new Planet({
        //         name: 'planet' + i, 
        //         scene: scene, 
        //         world: world, 
        //         color: randomColor,
        //         simSpeed: simSpeed,
        //         meshMap: meshMap,
        //         position: randomPosition,
        //         initialVelocity: randomVelocity,
        //         radius: randomRadius,
        //         gravityScale: randomGravityScale,
        //         gravityRadius: randomGravityRadius,
        //         mass: randomMass,
        //         maxOrbitDistance: randomMaxOrbitDistance,
        //         fixed: false
        //     });
        //     planets.push(planet);
        // }

        // let planet2 = new Planet({
        //     name: 'planet2', 
        //     scene: scene, 
        //     world: world, 
        //     simSpeed: simSpeed, 
        //     meshMap: meshMap,
        //     position: new CANNON.Vec3(0, 0, -10),
        //     initialVelocity: new CANNON.Vec3(-1, 1, 0), 
        //     radius: 2, 
        //     gravityScale: .1, 
        //     gravityRadius: 6, 
        //     mass: 5, 
        //     fixed: false
        // });
        // console.log(planet2);
        // planets.push(planet2);

        let ground = new CANNON.Body({ mass: 0, collisionFilterGroup: EVERYTHING_ELSE_GROUP, collisionFilterMask: PLAYER_GROUP | EVERYTHING_ELSE_GROUP });
        let groundShape = new CANNON.Plane();
        ground.addShape(groundShape);
        ground.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        ground.position.set(0, 0, 0);
        // world.addBody(ground);

        let groundGeometry = new THREE.PlaneGeometry(100, 100);
                    
        let groundMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide });
        let groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2;
        groundMesh.receiveShadow = true;
        groundMesh.position.set(0, 0, 0);

        // scene.add(groundMesh);

        //we will add lines to show the global axes
        

    }

    function createPlayer() {
        let lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 0)]);
        let lineMaterial = new THREE.LineBasicMaterial({ color: 0xffff00 });
        line = new THREE.Line(lineGeometry, lineMaterial);
        scene.add(line);

        player = new Player({
            name: 'player',
            scene: scene,
            world: world,
            position: new CANNON.Vec3(0, 101, 0),
            camera: camera,
            meshMap: meshMap,
        })
        playerBody = player.body;
        // let playerMesh = player.mesh;
        // console.log(player.mesh);

        scene.player = player;

        // bindMeshToBody(playerMesh, playerBody);

        window.addEventListener('click', () => {
            if(!player.isLocked && !isTouchDevice()) {
                player.enabled = true;
                player.lock();
            }
        });
       

        // playerBody = new CANNON.Body({ mass: .1, fixedRotation: true });
        // let playerShape = new CANNON.Box(new CANNON.Vec3(.1, .2, .1));
        // playerBody.addShape(playerShape);
        // playerBody.position.set(0, 5, 0);
        // playerBody.timeScale = 1;
        // world.addBody(playerBody);


        // let playerGeometry = new THREE.SphereGeometry(.1, 32, 32);
        // let playerMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        // playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        // playerMesh.castShadow = true;

        // let lineXGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(1, 0, 0)]);
        // let lineXMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
        // let lineX = new THREE.Line(lineXGeometry, lineXMaterial);
        // playerMesh.add(lineX);

        // let lineYGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 1, 0)]);
        // let lineYMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        // let lineY = new THREE.Line(lineYGeometry, lineYMaterial);
        // playerMesh.add(lineY);

        // let lineZGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, 1)]);
        // let lineZMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
        // let lineZ = new THREE.Line(lineZGeometry, lineZMaterial);
        // playerMesh.add(lineZ);

        // let forwardLineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0, 0, 0), new THREE.Vector3(0, 0, -1)]);
        // let forwardLineMaterial = new THREE.LineBasicMaterial({ color: 0x00ff00 });
        // let forwardLine = new THREE.Line(forwardLineGeometry, forwardLineMaterial);
        // playerMesh.add(forwardLine);
    }

    function getClosestPlanet(body) {
        let origin = new CANNON.Vec3(0, 0, 0);
        let closestPlanet = origin;
        let closestDistance = body.position.distanceTo(closestPlanet);
        let closestBody = null;
        planets.forEach(planet => {
            let distance = new CANNON.Vec3().copy(planet.body.position).vsub(body.position).length() - planet.radius;
            if (distance < closestDistance && distance < (planet.gravityRadius - planet.radius)) {
                closestDistance = distance;
                closestPlanet = planet.body.position;
                closestBody = planet.body;
            }
        });
        if(closestPlanet === origin) {
            closestPlanet = null;
        }
        // console.log(closestPlanet); 
        return closestBody;
    }

    function bindMeshToBody(mesh, body) {
        meshMap.set(body, mesh);
    }

    function syncMeshes() {
        world.bodies.forEach((body) => {
            body.angularDamping = 0;
            body.linearDamping = 0;
            let mesh = meshMap.get(body);
            if (mesh) {
                mesh.position.copy(body.position);
                mesh.quaternion.copy(body.quaternion);
            }
        });
    }
    // camera.lookAt(0, 0, 0);

    function lightSetup() {
        light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(0, 100, 0);
        light.castShadow = true;
        light.shadow.bias = -0.0001;
        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;


        scene.add(light);
    }

  
    function animate() {
        let delta = clock.getDelta();

        // console.log(playerBody

        

        if(player) {

            // if(!player.enabled) tut.style.display = 'flex';

            let playerPosition = playerBody.position;


            light.position.set(playerPosition.x, playerPosition.y + 100, playerPosition.z);
            light.target.position.set(playerPosition.x, playerPosition.y, playerPosition.z);
            light.target.updateMatrixWorld();

            light.shadow.camera.position.set(playerPosition.x, playerPosition.y + 100, playerPosition.z);
            light.shadow.camera.updateProjectionMatrix();

            playerBody.velocity.scale(0.9, playerBody.velocity);
            playerBody.angularVelocity.scale(0.9, playerBody.angularVelocity);

            // align player y axis with planet
            let closestPlanet = getClosestPlanet(playerBody);



            if(camera.posDest) {
                let cameraTargetPos = new THREE.Vector3(camera.posDest.x, camera.posDest.y, camera.posDest.z);
                camera.position.lerp(cameraTargetPos, .1);
            }

            camera.rotation.x = camera.rotation.x + (camera.xDest - camera.rotation.x) * .1;

            if(closestPlanet === null || player.isSpaceShip) {
                playerBody.orbitBody = null;                

                if (playerBody.mouseRotX !== undefined) {
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -playerBody.mouseRotX * .005);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);

                    // Reset mouseRotX to avoid continuous rotation
                    playerBody.mouseRotX = 0;
                }
                if(playerBody.mouseRotY !== undefined) {
                    let xRotationQuaternion = new CANNON.Quaternion();
                    xRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -playerBody.mouseRotY * .005);
                    playerBody.quaternion = playerBody.quaternion.mult(xRotationQuaternion);

                    // Reset mouseRotY to avoid continuous rotation
                    playerBody.mouseRotY = 0;
                }

                if(keys['KeyE']) {
                    //rotate player right
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), -0.05);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);
                }
                if(keys['KeyQ']) {
                    //rotate player left
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), 0.05);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);
                }
                
            } else {

                let planetCenter = closestPlanet.position;
                player.body.orbitBody = closestPlanet;
                let planetUpWorld = playerPosition.vsub(planetCenter);

                let planetUpLocal = playerBody.vectorToLocalFrame(planetUpWorld);                
                let playerUpLocal = new CANNON.Vec3(0, 1, 0);

                playerUpLocal.normalize();
                planetUpLocal.normalize();

                let dot = playerUpLocal.dot(planetUpLocal);
                let angle = Math.acos(dot);

                let axis = playerUpLocal.cross(planetUpLocal);
                axis.normalize();

                let q = new CANNON.Quaternion();
                q.setFromAxisAngle(axis, angle);
                let targetQuaternion = playerBody.quaternion.mult(q);

                playerBody.quaternion = playerBody.quaternion.slerp(targetQuaternion, .1);
                
                let quaternion = new CANNON.Quaternion();
                quaternion.setFromEuler(closestPlanet.angularVelocity.x * delta, closestPlanet.angularVelocity.y * delta, closestPlanet.angularVelocity.z * delta, 'XYZ');
                planetUpWorld = quaternion.vmult(planetUpWorld);

                playerBody.position = planetCenter.vadd(planetUpWorld);
                // playerBody.velocity.copy(closestPlanet.velocity);
                // playerBody.angularVelocity.copy(closestPlanet.angularVelocity);
                // console.log(closestPlanet.velocity, closestPlanet.angularVelocity);
                // console.log(playerBody.velocity, playerBody.angularVelocity);

                if (playerBody.mouseRotX !== undefined) {
                    let yRotationQuaternion = new CANNON.Quaternion();
                    yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 1, 0), -playerBody.mouseRotX * 0.01);
                    playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);

                    playerBody.mouseRotX = 0;
                }
                if(playerBody.mouseRotY !== undefined) {
                    camera.rotation.x -= playerBody.mouseRotY * .005;
                    camera.xDest = camera.xDest - playerBody.mouseRotY * .005;
                    playerBody.mouseRotY = 0;
                }

            }

            if(keys['ShiftLeft']) {
                player.boosting = true;
            } else {
                player.boosting = false;
            }

            let moveSpeed = 50;
            moveSpeed = player.boosting ? moveSpeed * 10 : moveSpeed;

            if(keys['Space']) {
                playerBody.applyLocalForce(new CANNON.Vec3(0, 0, -moveSpeed), new CANNON.Vec3(0, 0, 0));
                player.spaceDown = true;
            } else {
                player.spaceDown = false;
            }
            
            if(keys['KeyE']) {
                //rotate player right
                let yRotationQuaternion = new CANNON.Quaternion();
                yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), -0.05);
                playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);
            }
            if(keys['KeyQ']) {
                //rotate player left
                let yRotationQuaternion = new CANNON.Quaternion();
                yRotationQuaternion.setFromAxisAngle(new CANNON.Vec3(0, 0, 1), 0.05);
                playerBody.quaternion = playerBody.quaternion.mult(yRotationQuaternion);
            }

            if(stars) stars.position.copy(playerBody.position);

            // console.log(keys)

        }

        world.bodies.forEach(body => {
            body.inOrbit = false;
            body.orbitBody = null;
        });

        scene.planets = planets;


        planets.forEach(planet => {
            planet.update(delta);
        });


        world.step(delta);

        if(keys['KeyT']) {
            player.toggleSpaceShip();
            spaceship.innerHTML = player.isSpaceShip ? 'Intergalactic' : 'Surface Explorer';
            modeSub.innerHTML = player.isSpaceShip ? 'Zero-Gravity, Higher Speed' : 'Affected by Gravity'
            keys['KeyT'] = false;
        }
        // console.log(playerBody)
        // console.log(sun.body.position);
        cannonDebugger.update();
        syncMeshes();
        // controls.update();
        // stats.update();
        renderer.render(scene, camera);
    }


</script>
</html>